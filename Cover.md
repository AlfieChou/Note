无法理解更复杂的程序逻辑和数据流 静态分析 更智能的输入生成
插桩 性能下降 开销增大
支持多线程并行 
提供深入的漏洞分析方法


afl_maybe_lo cur_loc  边 索引
classify_word   mem16[0] = count_class_lookup16[mem16[0]];
simplify_trace  
classify_counts  
discover_word  
二进制  
源代码  

阅读一本书，绘制一张图表来记录你所阅读的每个章节及其之间的联系=AFL边覆盖统计  

程序=一本书，“章节”=程序的不同功能部分，“页面”=代码中的基本块。  
在程序执行时，跳转从一个基本块到另一个基本块就像是从一章跳到另一章。  
AFL的目的是要记录下你从哪一页跳转到了哪一页，即哪个基本块跳转到了哪个基本块。

在开始测试之前，AFL会给这本“书”做一个特别的准备工作，就像在每个章节开始的地方加上一个独特的书签。在技术上，这个过程称为插桩（instrumentation），AFL通过修改程序的代码，在每个基本块的开始插入特殊的标记代码。   

当你开始阅读（即程序开始执行）时，每次你到达一个新的章节（基本块），就会记录你从哪里来（前一个基本块）。这就像每次翻到带书签的页面时，你都会在一张图表上记录说：“我**从第X页来到了第Y页**。”在程序中，这个记录过程是通过更新一个位图（bitmap）来完成的，其中每个跳转都映射到位图中的特定位。

随着测试的进行，这本书的每个页面可能会被阅读很多次，但是，AFL特别关心的是那些**新发现的或很少访问的路径**。每当发现一个新的跳转组合，也就是说，每当你找到一条从未走过的路径从一个章节到另一个章节时，AFL就会特别兴奋，因为这可能是发现程序错误的关键线索。

最后，AFL不断鼓励自己去探索新的章节和新的跳转组合，就像一个渴望发现书中隐藏故事的读者。为了实现这一目标，它会试着改变输入数据（测试用例），希望能够触发新的代码路径，就像是尝试不同的阅读顺序以发现书中不为人知的秘密。

总之，AFL统计边覆盖的过程就像是在绘制一本书的详细阅读地图，并且不断寻找新的路线和链接以完善这张地图。这个过程帮助AFL找到那些最不常走的路径，因为这些往往是隐藏软件错误和安全漏洞的地方。


在这个比喻中，classify_word 函数就像一种特殊的**书签**，它不仅能够标记你访问过的章节（基本块），还能够按照你访问它们的**频率和顺序**，把这些章节分成几个**类别**。count_class_lookup16 数组就好比一个分类指南，其中定义了如何**根据访问的次数和特征对章节进行分类**。

这个函数的作用有点像是在你的阅读地图上高亮那些特别重要或者不寻常的路径。例如，如果你发现自己第一次从一个章节跳到了另一个全新的章节，classify_word 函数可以用一个特别的标记来高亮这个**新路径**，提醒你这是一个可能隐藏有新故事的线索。相对的，如果某个路径你已经走过很多次，那么这个函数可能就会给它一个**普通的标记，因为它不太可能隐藏新的信息**。

通过这种方式，classify_word 函数帮助AFL**快速识别那些最有可能包含新发现和潜在错误的代码路径**。在我们的书籍比喻中，它帮助读者（也就是AFL）找到那些可能揭示新章节或未被注意的细节的关键线索。


在这个比喻中，classify_counts 函数的作用可以看作是对你阅读书籍时的记录进行进一步的整理和分类。想象一下，你的记录包含了每次翻页时从一个章节跳转到另一个章节的详细信息，记录了哪些跳转是新的，哪些是重复的，以及每个跳转发生的频率。

如果把这些跳转比作计数值，那么classify_counts函数就是在**处理这些计数值**，决定哪些记录是值得特别注意的（比如新发现的跳转），哪些可以归类为常见或不太重要的。classify_word在这过程中起到关键作用，它对于每个64位的记录（可以想象为记录了多次阅读某个章节序列的信息）进行分类，将其映射为一个更简洁的形式。这有助于你更快地**识别和关注那些可能揭示新情节或隐藏信息的跳转**（即代码执行路径）。

将这个过程应用到AFL中，这意味着classify_counts函数通过**处理和分类覆盖率位图上的计数值**，帮助AFL确定哪些代码路径是新发现的，哪些已经被充分探索。这样做可以优化AFL的搜索算法，让它更专注于探索那些潜在含有错误或漏洞的新路径，同时忽略那些已经被广泛测试过的路径。

总体来说，classify_counts函数就像是对阅读地图上的路径进行**管理和优化**，**确保我们注意力的焦点是发现新的章节链接和故事线索，而非已知信息的重复阅读。这使得测试过程更有效率，并提高了发现重要问题的概率**。


在这个比喻中，simplify_trace 函数相当于将地图上的某些**路径进行简化**，使得图表更加清晰易读。在一本书的阅读过程中，这就像是将那些多次重复阅读的章节或者那些不太可能提供新信息的部分进行缩减，从而将注意力集中在那些更有可能带来新发现的章节。

具体来说，当我们在阅读一本书并试图记录我们所阅读的每个章节及其之间联系的时候，如果我们把每次阅读都详细记录下来，那么我们的记录将会非常庞大和复杂。如果你的目的是要找到新的故事线索或者前所未见的章节联系，那么对于那些已经被反复阅读和确认的章节，就没有必要进行详细记录。simplify_trace 通过 simplify_lookup 数组，将那些频繁出现的、信息量低的记录转换成一种更简化的形式。

这样做的好处是：
**记录新的路径详细信息**
提高效率：减少了需要处理的数据量，因为简化后的位图占用的空间更小，处理起来更快。
突出重要路径：简化的过程可以帮助突出那些不常见的路径，因为常见路径已经被归纳为一种更简单的形式。
节省资源：在资源有限的情况下，简化可以帮助节约存储和计算资源，使得AFL能够更长时间地运行，探索更多的代码路径。
换句话说，simplify_trace 函数在地图绘制过程中帮助你识别和关注那些最可能带来新发现的“阅读路径”，而非那些已经熟悉的旧路线。这在寻找软件中潜在的错误和漏洞时是非常重要的，因为它们往往隐藏在较少被测试的代码路径中。


在这个比喻中，discover_word 函数可以看作是一个过程，它帮助你识别和标记那些在你阅读书籍时首次遇到的新章节或新链接。设想你有两张地图：一张是“virgin map”，它代表了你未探索的书籍章节；另一张是“current map”，记录了你最近一次阅读时所经过的章节。

当你在阅读时，每次进入一个新的章节，你就会在你的“current map”上做一个标记。discover_word 函数的作用是，它会检查你在“current map”上做的每个标记，并与“virgin map”进行对比。如果它在“virgin map”上发现一个对应的未标记的区域，这意味着你发现了一条新的路径或者一个新的章节，那么它会在“virgin map”上更新这个区域。这表明你在书中发现了一些新的内容。

应用到AFL中，这意味着discover_word函数用于**识别新的代码执行路径**。每当AFL执行一个测试用例，并且这个用例触发了代码中之前未执行过的路径（边），discover_word就会更新“virgin map”（也被称为“未命中的边缘映射”）以反映这个新发现。这是一个关键的功能，因为它帮助AFL**跟踪哪些路径已经被探索过，哪些尚未被触及，从而可以优先考虑那些未探索的路径，以便发现潜在的错误或漏洞**。

所以，在书籍阅读的比喻中，“virgin map”就是你未探索的章节和故事链接的记录，而discover_word函数就是在你进行新的探索时更新这张地图的过程，帮助你可视化你的新发现，并指导你的下一步探索。


在计算机安全测试中，qemu 模式的 qemuafl 代码中的 afl_maybe_log 函数是负责记录测试过程中的每一次代码执行路径。在动态二进制翻译的上下文中，qemu 使用 Tiny Code Generator (TCG) 来将目标机器代码转换为主机可以执行的中间代码。afl_maybe_log 函数会在这个过程中的一个**关键点检查是否应该记录当前路径，并在需要时执行记录**。

如果我们继续使用之前的书籍阅读比喻，afl_maybe_log 函数可以比作是一个**内在的判断机制**，或者说是一个**决策点**，它决定在你阅读书籍的过程中是否值得停下来记录你当前阅读的章节和它们之间的链接。每当你翻到一个新的页面或者章节，这个机制会快速判断：

这个章节是否包含了新信息，即之前没有记录或者阅读过的内容。
如果是新信息，它会在你的阅读记录中加上新的笔记或者标记。
在 qemu-afl 的环境中，afl_maybe_log 函数同样做出是否记录的决定，但它是基于是否执行了新的、未知的代码路径。如果检测到一个新的路径，它会记录下来，这样 AFL (American Fuzzy Lop) 就可以用这个信息来指导后续的模糊测试，注重那些未被充分测试的路径。

这个函数在保证模糊测试效率和有效性方面起到了重要的作用，它确保资源被用于探索那些最有可能发现软件缺陷的新路径，而不是重复已知的、没有问题的路径。在比喻中，这个机制帮你专注于阅读那些可能揭示新情节或重要信息的部分，而不是那些已经熟悉的内容。



AFL (American Fuzzy Lop) 是一个由 Michał Zalewski 创建的安全性测试工具，它利用模糊测试技术来发现软件中的漏洞。AFL 使用一种称为“覆盖导向的模糊测试”的方法，该方法特别关注程序在处理各种输入时的行为。

边覆盖（edge coverage）统计是AFL用来**跟踪已经执行的路径的机制**。边覆盖并不是直接关注代码中的每一行是否执行过，而是关注程序在执行过程中**是否通过了某些特定的路径（控制流边）**。具体来说，它记录了从一个基本块（basic block，一段顺序执行代码，没有跳转除了最后）到另一个的**转移**。这种方法可以提供比简单的行覆盖更详尽的信息，因为它能捕捉到不同的**执行路径**。

AFL的边覆盖统计过程大致如下：

插桩（Instrumentation）：在编译时，AFL会修改目标程序，插入额外的代码来监视哪些代码段被执行。这种插桩能够在运行时跟踪程序的控制流转移，即从一个基本块到另一个基本块的边。

初始化：AFL初始化一个覆盖率位图，记录哪些控制流边被触发。

模糊测试循环：AFL使用各种策略生成输入，并**运行被插桩的目标程序**，记录下每个输入如何影响覆盖率位图。AFL会保留那些能够**触及新路径的输入用于后续的测试**。

边覆盖统计：通过比较位图的变化，AFL可以知道哪些新的控制流边被执行。如果一个新输入导致了位图的变化，即发现了新的边覆盖，那么这个输入可能揭示了一个新的代码执行路径，这增加了发现潜在错误或漏洞的机会。

演化：AFL会对有效的输入进行变异，以期产生更多的新覆盖率，寻找程序处理异常输入时的潜在漏洞。

AFL的这种方法非常有效，因为它能持续地细化测试用例，逐步探索程序的状态空间，并且能够自动发现引发崩溃或者异常行为的输入。