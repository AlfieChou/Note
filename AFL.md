## AFL   
自动化 高速率 不重复     
覆盖率引导：记录输入样本的代码覆盖率，从而调整输入样本以提高覆盖率，增加发现漏洞的概率    

**模糊测试**  通过向目标系统提供非预期的输入并监视异常结果来发现软件漏洞的方法  
半随机数据注入程序并监视异常情况（如崩溃、断言失败或潜在的内存泄漏）技术    
大量生成并发送异常、意外或随机的数据到程序中，然后观察程序是否崩溃或表现出异常行为       
适用于发现处理外部输入数据时可能存在的安全漏洞，比如缓冲区溢出、内存泄露等。  

1. 从源码编译程序时进行插桩，以记录代码覆盖率（Code Coverage）；    
插桩：编译过程中修改程序的源代码或编译后的二进制代码，以便嵌入额外的代码。用于收集运行时数据。  
监测程序对特定输入的响应，以此来评估测试的有效性 模糊测试前会对目标程序进行插桩，以追踪哪些代码路径被执行了，从而指导测试用例的生成，以探索更多的代码分支    

源码级别插桩：直接修改程序的源代码，加入额外的函数调用或语句。  
编译器插桩：利用编译器提供的特定功能在编译时自动插入额外代码。例如，LLVM编译器支持许多用于插桩的功能。  
二进制插桩：在编译完成后，直接对二进制执行文件进行修改，插入监测代码，这样做的优点是不需要源代码。  


2. 选择一些输入文件，作为初始测试集加入输入队列（queue）；   
 AFL开始于一组种子输入文件，这些文件通常是有效的输入数据，可以触发程序的不同区域    
 
3. 将队列中的文件按一定的策略进行“突变”；     
 AFL在这些种子的基础上，采用一系列的随机变异策略来生成新的测试用例    

bitflip：按位翻转，1变为0，0变为1    
arithmetic：整数加/减算术运算  
interest：把一些特殊内容替换到原文件中  
dictionary：把自动生成或用户提供的token替换/插入到原文件中  
havoc：“大破坏”，是前面几种变异的组合  
splice：“连接”，此阶段会将两个文件拼接起来得到一个新的文件  


4. 如果经过变异文件更新了覆盖范围，则将其保留添加到队列中;   
AFL使用轻量级的覆盖率跟踪机制来检测每个测试用例的代码覆盖率   

5. 上述过程会一直循环进行，期间触发了crash的文件会被记录下来。    
AFL使用覆盖率信息来指导后续的模糊测试，优先选择那些触及新代码路径的测试用例进行进一步的模糊变异   
不同于简单地随机生成数据，AFL关注于覆盖新的、未探索的代码路径。  
如果AFL检测到程序崩溃，它会保存导致崩溃的输入文件，以便后续分析。  




用于创建模块化和可复用模糊测试器的框架    
可自定义的模糊测试管道    
解决模糊测试研究领域中存在的代码库高度碎片化的问题    
通过模块化和可复用的组件来共同构建和分享模糊测试器，从而降低合并不同技术工程成本，提高了研究的协同性和效率   
标准化模糊测试技术的评估方法，使得不同技术的比较更加公平和客观。   



现代模糊测试实体  

## 输入   
直接存储和操作字节数组 抽象语法树存储  

## 语料库   
存储输入及其相关元数据的存储空间。  
内存语料库使模糊测试器更快，大目标内存耗尽。  
磁盘语料库允许用户检查模糊测试器的状态，但引入了磁盘操作的瓶颈。影响了并行模糊测试的可扩展性，并需要一个标准库来执行文件IO操作。  

两个独立的语料库   
存储测试用例，模糊测试器进化算法的组成部分   
存储解决方案，满足模糊测试器目标的测试用例（例如，程序崩溃）。  

## 调度器    
调度器是与语料库相连的组件。通过从语料库中选择一个条目，请求下一个要模糊测试的测试用例。选择  

## 阶段 广泛的实体   
对语料库中单个测试用例进行操作的组件。  
调度器选择一个测试用例，然后模糊测试器在给定输入上执行每个阶段。  
保持触发覆盖点的同时，减少从语料库获得的测试用例的大小  

## 观察者   
从目标的单次执行中提供信息的实体。  
为了对输入的执行进行推理，模糊测试器执行它，然后查看观察者。  
执行后观察者状态的快照在对模糊测试器状态的影响上等同于执行本身。这样定义观察者特别有用，当一个分布式模糊测试器可以跨多个节点发送观察者状态时。这避免了在对非常慢的目标进行模糊测试时，需要使用相同输入重新执行。  

一个例子是覆盖图，常见的基于覆盖的模糊测试器，如AFL或HonggFuzz使用。该图在执行期间填充以报告执行的边。这个信息不跨执行保持，并且是对程序动态属性的一次观察。  

其他诸如Ijon[5]或FuzzFactory[58]的模糊测试器使用不同形式的观察者，但始终依赖于一个映射来跟踪代码覆盖范围之外的其他指标。  

## 执行器 执行目标  
输入系统执行目标的组件。 如何执行目标，还定义了与目标单次运行相关的所有易失性操作。  
例如，执行器负责告知程序模糊测试器想要在运行中使用的输入，例如，通过写入内存位置或将其作为参数传递给测试函数。执行器还维护了与每次执行相关的一组观察者。  

## 反馈  
对测试程序执行结果进行分类的实体，判断执行是否有趣。通常，这些信息用来决定是否将相应的输入添加到语料库中。  
vs观察者 反馈通常处理一个或多个观察者报告的信息 以决定执行是否有趣(达到之前未见过的控制流图边的输入)   
找到满足特定目标的解决方案=反馈=目标(崩溃)  

## 变异器    
获取一个或多个输入并生成一个新派生输入的实体。  
与特定的输入类型相关联。  
多位级变异(翻转 交换)。了解到输入格式，并突变输入的内部表示，交换抽象语法树中的节点  

## 生成器   
设计用来从头开始生成新输入的组件。  
随机生成器生成随机输入。  
例如，Nautilus [4]使用基于语法的生成器来创建初始语料库，并将子树生成器作为其语法变异器的一种变异。    


## 绕过障碍   
敏感度：在这里指模糊测试器对代码变化的反应程度，过高的敏感度可能导致产生过多相似的测试用例，造成资源浪费。   
复杂的输入验证、特定的执行路径条件、代码保护机制等，这些都可能阻碍模糊测试器深入探索应用程序的潜在漏洞    

## 输入引导   
使用种子文件或特定的测试用例，这些文件是专门设计来满足程序的输入要求，可以帮助模糊测试器通过复杂的**输入检验**。  
插桩优化：AFL利用插桩来监控程序的代码覆盖率。通过优化插桩技术，可以更有效地**跟踪**哪些代码被执行，从而更聪明地指导测试用例的生成。  
动态分析：与**运行时分析**工具结合使用，比如使用调试器或者覆盖率分析工具，来识别那些很少或从未被执行的代码路径。  
路径敏感：开发和使用更智能的算法来理解和适应程序的路径逻辑，这些算法可以帮助模糊测试器生成能够触发**特定**路径的输入。  
**自定义突变**：AFL允许用户定义自己的突变策略，可以针对特定的程序逻辑设计突变操作，以提高测试用例的相关性。 
持久模式：一种优化AFL性能的模式，能减少程序启动次数，加快测试速度，以更高效地绕过初始化等耗时的障碍。  



## 结构感知模糊测试-模糊测试器意识到输入格式   
提高测试有效性：通过了解输入数据的结构，更精确地构造或修改测试用例，有效触发更深层次的代码路径，**提高代码覆盖率**。  
节省时间和资源：减少无效的测试用例，提高找到漏洞的效率。不必浪费资源在那些因格式不正确而根本不会被程序处理的输入上。   
发现更复杂的漏洞：某些漏洞只有在输入数据满足特定结构条件时才会触发。结构感知模糊测试能够生成满足这些条件的测试输入，从而发现这些复杂的漏洞。   
针对性测试：针对特定的输入结构或者协议进行定制化测试，能够更深入地探究可能存在安全风险的区域。   

在AFL中，结构感知模糊测试可以通过多种方式实现，如使用AFL的自定义突变策略、插件或与其他工具集成（比如集成语法分析器来理解输入格式）。这些方法都旨在使AFL能够生成符合目标程序预期格式和逻辑的输入，从而**提高发现复杂漏点**的可能性。   
种子语料库：在模糊测试中，种子集是初始测试用例集，用于引导测试过程。   
正交技术：在这里指的是与当前方法在概念或实现上不相关的技术，可以与之独立使用或组合使用。   
 
## 语料库**调度**   
语料库中选择下一个要使用的测试用例  最简单随机选择或先进先出（FIFO）队列。   
AFL：在每个队列周期中选取语料库中的一部分“优选”种子。这些种子是基于执行速度和输入长度选择的，同时保留最大覆盖率。   
概率抽样AFL++的最近改进。语料库中的每个测试用例映射到概率和一个更“有希望”的相邻测试用例，基于计算出来的分数   
MinimizerScheduler：一种基于AFL的调度器，通过权重定制和map反馈计算最小集合。   

## 能量分配 
**优化**模拟测试过程 测试资源   
决定每个测试用例变异创建新测试用例的次数。每个样本被分配的能量越多，它就会被更频繁地变异和测试，进而有更高的机会发现新的代码路径或者漏洞   
语料库中单个输入需要变异多少次才能创建新的测试用例  功率调度问题（测试用例变异次数的智能分配，以优化模糊测试过程） 使用一个恒定值/为每个种子分配一个给定区间内的随机值    
执行时间、覆盖率密度和测试用例的创建时间等指标按比例分配能量   

## 通用的位级模糊测试器     
自动化的错误检测。它通过对目标软件的输入数据进行**随机或半随机的修改**，生成新的、可能会触发软件错误的输入数据   
代码覆盖率      
差异化模糊测试：一种测试方式，旨在比较不同实现（如虚拟机或解释器）在相同输入下的差异，用于查找潜在的错误或不一致。   

高效的差异化模糊测试前端 对相同输入的执行结果是否存在差异   